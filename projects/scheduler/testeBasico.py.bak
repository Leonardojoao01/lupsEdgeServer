from datetime import datetime
import time
import os
import sqlite3

from apscheduler.schedulers.background import BackgroundScheduler


def tick(a):
	print(a)
	#print(b)
    #print('Tick! The time is: %s' % datetime.now())
def te():
    print("foi")

if __name__ == '__main__':
    scheduler = BackgroundScheduler()

	conn = sqlite3.connect('dados_sensores.db')
	cursor = conn.cursor()

	cursor.execute("""
	SELECT * FROM dados_sensores;
	""")
  	
  	for linha in cursor.fetchall():
	#print(linha[2])
		rslt = int(linha[2])
		sensor = linha[1]
		scheduler.add_job(tick, 'interval', seconds = rslt,id = "bc", args=[sensor])	

	conn.close()

    #scheduler.add_job(tick, 'interval', seconds = 10,id = "ab", args=[a,b])
    #scheduler.add_job(tick, 'interval', seconds = 5,id = "bc", args=[c,b])
    scheduler.start()
    #print('Press Ctrl+{0} to exit'.format('Break' if os.name == 'nt' else 'C'))

    a = 5

    try:
        # This is here to simulate application activity (which keeps the main thread alive).
        a = 0
        while True:
            time.sleep(2)
            if(a == 10):
                scheduler.remove_job("bc")
                scheduler.add_job(te, 'interval',seconds = a, id ="pica")
            a = a + 1
    except (KeyboardInterrupt, SystemExit):
        # Not strictly necessary if daemonic mode is enabled but should be done if possible
        scheduler.remove_job("bc")
        #scheduler.shutdown()
